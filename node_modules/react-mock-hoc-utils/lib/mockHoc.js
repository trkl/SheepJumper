"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jestMockHocMethod = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require("path");
var stack = require("callsite");

// * -------------- Higher-Order-Component Mocking -------------- *
var jestMockHocMethod = exports.jestMockHocMethod = function jestMockHocMethod(path, method) {
  return jest.doMock(path, function () {
    return method;
  });
};

var MockHOC = function MockHOC(path, methodName, mockFunction) {
  return function (hocProp) {
    if (!path || typeof path !== "string") throw "MockHoc | MockHocHierarchy: the path provided was not valid, but instead: " + path;
    if (!methodName || typeof methodName !== "string") throw "MockHoc | MockHocHierarchy: the methodName provided was not valid, but instead: " + methodName;

    var mockMethod = {};
    mockMethod[methodName] = function (WrappedComponent) {
      return function (props) {
        if (hocProp) props = _lodash2.default.assign(hocProp, props);

        return _react2.default.createElement(WrappedComponent, props);
      };
    };
    mockFunction(path, mockMethod);
    //jest.doMock(path, () => mockMethod);
  };
};

var MockHOCHierarchy = function MockHOCHierarchy(mocks) {
  return function (requireName) {
    if (!Array.isArray(mocks)) throw "MockHocHierarchy: the mocked data is not an arrays, but instead: " + mocks;

    mocks.forEach(function (mock) {
      var path = mock.path,
          methodName = mock.methodName,
          hocProp = mock.hocProp,
          contextModuleMethod = mock.contextModuleMethod;

      MockHOC(path, methodName, contextModuleMethod)(hocProp);
    });

    return require(requireName);
  };
};

var MockHoc = function () {
  function MockHoc(wrappedComponentPath, origin, clearOnCreation) {
    _classCallCheck(this, MockHoc);

    this.mock = this.mock.bind(this);
    this.with = this.with.bind(this);
    this.clear = this.clear.bind(this);
    this.create = this.create.bind(this);
    this.createPure = this.createPure.bind(this);

    if (clearOnCreation) this.clear();

    this.requiredPath = wrappedComponentPath;
    this.origin = origin;

    this.imported = [];

    // ? this parses the file name to potential get the function/class name of the "imported" module
    // ?? this is used, in case the provided apply method does not find an export with the name of >target<
    this.potentialRequireMethodName = (0, _utils.GetFileName)(wrappedComponentPath);

    // ? if the origin is not specifided, then try to determine it through the call-stack
    if (!this.origin) {
      var sites = stack();
      if (sites.length >= 3) this.origin = path.dirname(sites[2].getFileName());
    }

    // ? if the origin does not end with a trailing '/', then one needs to be added to reduce failure from origin + path
    if (this.origin && this.origin[this.origin.length - 1] != "/") this.origin += "/";
  }

  _createClass(MockHoc, [{
    key: "mock",
    value: function mock(path) {
      var methodName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "#uc";
      var contextModuleMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!path || typeof path !== "string") throw "MockHoc: [mock] missing path, instead recieved " + path;

      // ? if no method is specified then try and parse it out of the path
      if (!methodName || typeof methodName !== "string") methodName = "#uc";

      if (methodName == "#uc" || methodName == "#lc") methodName = (0, _utils.SetFirstCase)((0, _utils.GetFileName)(path), methodName); // ? <-- methodName can be a number matching the StartingCase, if it is not a string

      if (typeof contextModuleMethod !== "function") {
        path = this.origin + path;
        contextModuleMethod = jestMockHocMethod;
      }

      // ? store it for when applied is called
      this.imported.push({
        path: path,
        methodName: methodName,
        hocProp: {},
        contextModuleMethod: contextModuleMethod
      });

      return this;
    }
  }, {
    key: "with",
    value: function _with(injectedProps) {
      var importCount = this.imported.length;
      if (importCount < 1) return;

      this.imported[importCount - 1].hocProp = _lodash2.default.assign(this.imported[importCount - 1].hocProp, injectedProps);

      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      jest.resetModules();
      return this;
    }
  }, {
    key: "createPure",
    value: function createPure() {
      return MockHOCHierarchy(this.imported)(this.origin + this.requiredPath);
    }
  }, {
    key: "create",
    value: function create() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";

      var req = MockHOCHierarchy(this.imported)(this.origin + this.requiredPath);

      // ? if the specified target is not found, then attempt to find a predicted target name instead
      // ?? if it finds neither, then throw a detailed, helpful error (as opposed to how jest handles it)
      if (!req[target]) {
        if (!req[this.potentialRequireMethodName]) throw "MockHoc [create]: could not find the exported target, \"" + target + "\", nor could it find the fallback target, \"" + this.potentialRequireMethodName + "\"";

        target = this.potentialRequireMethodName;
      }
      return req[target];
    }
  }]);

  return MockHoc;
}();

var constructMockHoc = function constructMockHoc(wrappedComponentPath) {
  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var clearOnCreation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return new MockHoc(wrappedComponentPath, origin, clearOnCreation);
};

exports.default = constructMockHoc;